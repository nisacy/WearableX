//
//  EncryHelper.m
//  Wearable
//
//  Created by Shinsoft on 17/2/26.
//  Copyright © 2017年 wearable. All rights reserved.
//

#import "EncryHelper.h"
#include <CommonCrypto/CommonDigest.h>

@implementation EncryHelper

+ (NSData *)data{
    Byte byte[] = {
        0x30,  0x82,  0x01,  0xA4,  0x30,  0x82,  0x01,  0x49,   0xA0,  0x03,  0x02,  0x01,  0x02,  0x02,  0x11,  0x40,
        0x01,  0x02,  0x03,  0x04,  0x05,  0x06,  0x07,  0x08,   0x09,  0x0A,  0x0B,  0x0C,  0x0D,  0x0E,  0x0F,  0x02,
        0x30,  0x0A,  0x06,  0x08,  0x2A,  0x86,  0x48,  0xCE,   0x3D,  0x04,  0x03,  0x02,  0x30,  0x42,  0x31,  0x11,
        0x30,  0x0F,  0x06,  0x03,  0x55,  0x04,  0x0A,  0x0C,   0x08,  0x54,  0x72,  0x61,  0x69,  0x6E,  0x69,  0x6E,
        0x67,  0x31,  0x2D,  0x30,  0x2B,  0x06,  0x03,  0x55,   0x04,  0x03,  0x0C,  0x24,  0x50,  0x72,  0x6F,  0x76,
        0x69,  0x73,  0x69,  0x6F,  0x6E,  0x20,  0x54,  0x65,   0x73,  0x74,  0x20,  0x41,  0x54,  0x45,  0x43,  0x43,
        0x35,  0x30,  0x38,  0x41,  0x20,  0x53,  0x69,  0x67,   0x6E,  0x65,  0x72,  0x20,  0x35,  0x30,  0x30,  0x41,
        0x30,  0x20,  0x17,  0x0D,  0x31,  0x35,  0x31,  0x32,   0x31,  0x36,  0x30,  0x32,  0x35,  0x31,  0x33,  0x37,
        0x5A,  0x18,  0x0F,  0x39,  0x39,  0x39,  0x39,  0x31,   0x32,  0x33,  0x31,  0x32,  0x33,  0x35,  0x39,  0x35,
        0x39,  0x5A,  0x30,  0x3D,  0x31,  0x11,  0x30,  0x0F,   0x06,  0x03,  0x55,  0x04,  0x0A,  0x0C,  0x08,  0x54,
        0x72,  0x61,  0x69,  0x6E,  0x69,  0x6E,  0x67,  0x31,   0x28,  0x30,  0x26,  0x06,  0x03,  0x55,  0x04,  0x03,
        0x0C,  0x1F,  0x50,  0x72,  0x6F,  0x76,  0x69,  0x73,   0x69,  0x6F,  0x6E,  0x20,  0x54,  0x65,  0x73,  0x74,
        0x20,  0x41,  0x54,  0x45,  0x43,  0x43,  0x35,  0x30,   0x38,  0x41,  0x20,  0x44,  0x65,  0x76,  0x69,  0x63,
        0x65,  0x30,  0x59,  0x30,  0x13,  0x06,  0x07,  0x2A,   0x86,  0x48,  0xCE,  0x3D,  0x02,  0x01,  0x06,  0x08,
        0x2A,  0x86,  0x48,  0xCE,  0x3D,  0x03,  0x01,  0x07,   0x03,  0x42,  0x00,  0x04,  0x81,  0x9A,  0x9B,  0x76,
        0x23,  0xE3,  0x20,  0xE9,  0x85,  0x6D,  0x74,  0xEE,   0xCC,  0x94,  0x60,  0x06,  0xDB,  0x7E,  0x64,  0xE3,
        0x86,  0xB3,  0x3B,  0xF5,  0x08,  0x42,  0x47,  0x39,   0x8E,  0x5D,  0xD3,  0x22,  0xAF,  0x5B,  0xDC,  0x57,
        0xBB,  0xC6,  0xC0,  0xD2,  0x18,  0xF8,  0x82,  0x01,   0x2F,  0x1E,  0x3B,  0xDA,  0xF7,  0xF2,  0xED,  0x22,
        0xAA,  0xCA,  0x88,  0xF5,  0x7C,  0x3A,  0xEE,  0x5A,   0x3C,  0x3E,  0x1D,  0xF5,  0xA3,  0x23,  0x30,  0x21,
        0x30,  0x1F,  0x06,  0x03,  0x55,  0x1D,  0x23,  0x04,   0x18,  0x30,  0x16,  0x80,  0x14,  0xA6,  0x87,  0x3D,
        0x89,  0xD7,  0x11,  0x67,  0x0F,  0x9E,  0x24,  0xC2,   0xA6,  0xFD,  0x41,  0xB2,  0x99,  0x27,  0xC6,  0x80,
        0x02,  0x30,  0x0A,  0x06,  0x08,  0x2A,  0x86,  0x48,   0xCE,  0x3D,  0x04,  0x03,  0x02,  0x03,  0x49,  0x00,
        0x30,  0x46,  0x02,  0x21,  0x00,  0xC3,  0x10,  0x54,   0xB6,  0x26,  0xE1,  0x02,  0x0B,  0x9E,  0xA8,  0x02,
        0xE7,  0xA4,  0x58,  0x0F,  0xC3,  0x94,  0x80,  0xA4,   0x64,  0xB2,  0xC8,  0x0A,  0x50,  0xE2,  0x69,  0x71,
        0x87,  0x32,  0x4B,  0xC3,  0xAA,  0x02,  0x21,  0x00,   0x84,  0xA2,  0x28,  0xED,  0xAB,  0x1D,  0xA9,  0x9A,
        0x16,  0x36,  0x77,  0x2A,  0x1E,  0xE0,  0xBB,  0x3B,   0x1F,  0x4B,  0xCF,  0xBC,  0x6B,  0xD2,  0x54,  0xBA,
        0xB7,  0x5F,  0x79,  0xBB,  0x56,  0x44,  0x30,  0xE4
    };
    
    NSData *data = [[NSData alloc] initWithBytes:byte length:424];
    return data;
}

+ (NSData*)PKCSSignBytesSHA256withRSA:(NSData*)plainData SecKeyRef:(SecKeyRef) privateKey{
    size_t signedHashBytesSize = SecKeyGetBlockSize(privateKey);
    uint8_t* signedHashBytes = malloc(signedHashBytesSize);
    memset(signedHashBytes, 0x0, signedHashBytesSize);
    
    size_t hashBytesSize = CC_SHA256_DIGEST_LENGTH;
    uint8_t* hashBytes = malloc(hashBytesSize);
    if (!CC_SHA256([plainData bytes], (CC_LONG)[plainData length], hashBytes)) {
        return nil;
    }
    
    SecKeyRawSign(privateKey,
                  kSecPaddingPKCS1SHA256,
                  hashBytes,
                  hashBytesSize,
                  signedHashBytes,
                  &signedHashBytesSize);
    
    NSData* signedHash = [NSData dataWithBytes:signedHashBytes
                                        length:(NSUInteger)signedHashBytesSize];
    
    if (hashBytes)
        free(hashBytes);
    if (signedHashBytes)
        free(signedHashBytes);
    
    return signedHash;
}

+ (BOOL)PKCSVerifyBytesSHA256withRSA:(NSData*) plainData signature:(NSData*)signature publicKey:(SecKeyRef)publicKey
{
    size_t signedHashBytesSize = SecKeyGetBlockSize(publicKey);
    const void* signedHashBytes = [signature bytes];
    
    size_t hashBytesSize = CC_SHA256_DIGEST_LENGTH;
    uint8_t* hashBytes = malloc(hashBytesSize);
    if (!CC_SHA256([plainData bytes], (CC_LONG)[plainData length], hashBytes)) {
        return nil;
    }
    
    OSStatus status = SecKeyRawVerify(publicKey,
                                      kSecPaddingPKCS1SHA256,
                                      hashBytes,
                                      hashBytesSize,
                                      signedHashBytes,
                                      signedHashBytesSize);
    
    return status == errSecSuccess;
}


+ (SecKeyRef)getPublicKeyReference:(NSData *)p12Data{
    
    NSMutableDictionary * options = [[NSMutableDictionary alloc] init];
    SecKeyRef privateKeyRef = NULL;
    //change to the actual password you used here
    [options setObject:@"password_for_the_key" forKey:(id)kSecImportExportPassphrase];
    CFArrayRef items = CFArrayCreate(NULL, 0, 0, NULL);
    OSStatus securityError = SecPKCS12Import((CFDataRef) p12Data,
                                             (CFDictionaryRef)options, &items);
    
    if (securityError == noErr && CFArrayGetCount(items) > 0) {
        CFDictionaryRef identityDict = CFArrayGetValueAtIndex(items, 0);
        SecIdentityRef identityApp =
        (SecIdentityRef)CFDictionaryGetValue(identityDict,
                                             kSecImportItemIdentity);
        securityError = SecIdentityCopyPrivateKey(identityApp, &privateKeyRef);
        if (securityError != noErr) {
            privateKeyRef = NULL;
        }
    }
    
    return privateKeyRef;
    
//    OSStatus sanityCheck = noErr;
//    
//    SecKeyRef pubKeyRefData = NULL;
//    NSMutableDictionary * peerPublicKeyAttr = [[NSMutableDictionary alloc] init];
//    
//    [peerPublicKeyAttr setObject:(id)kSecClassKey forKey:(id)kSecClass];
//    [peerPublicKeyAttr setObject:(id)kSecAttrKeyTypeRSA forKey:(id)kSecAttrKeyType];
//    [peerPublicKeyAttr setObject:peerTag forKey:(id)kSecAttrApplicationTag];
//    [peerPublicKeyAttr setObject:[NSNumber numberWithBool:YES] forKey:       (id)kSecReturnRef];
//    sanityCheck = SecItemCopyMatching((CFDictionaryRef) peerPublicKeyAttr, (CFTypeRef*)&pubKeyRefData);
//    
//    if(pubKeyRefData){
//        return pubKeyRefData;
//    }else{
//        return nil;
//    }
}

@end
